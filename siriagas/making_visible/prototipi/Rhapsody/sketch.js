// -
// Prototipo Rhapsody 0.1 by Siria Gasperoni [video, poseNet, graphic, Tone.js, skeleton, movement, sound]
// 2021 © Siria Gasperoni, Daniele @Fupete, Irene @iretrtr and the course DS-2021 at DESIGN.unirsm,
// github.com/ds-2021-unirsm — github.com/fupete - github.com/siriagas
// Educational purposes, MIT License, 2021, San Marino
// —
//
// Help:
//click on the canvas to save the melody generated by the movements and manipulate the graphics
//
//click on the interface button to change the key of the melody
let video;
let poseNet;
let mic, recorder, soundFile;
let state = 0;
let poseA;
let poseB;
// variabili grafica
var thold = 3;
var spifac = 1.05;
var outnum = 0;
var drag = 0.01;

var big = 40;
var nwalker = 15; // scia 

let bodiesA = []; 
var mXA = 0.0;
var mYA = 0.0;

let bodiesB = [];
var mXB = 0.0;
var mYB = 0.0;

let posesX = [];
let posesY = [];
let skelPose = [];

let w = 0; //singolo segmento

let beat;
let bars = [];
let playNotes = [];

//libreria Tone Js accordi scala di Do
let chords = [
  ["C4", "G4", "E4", "B4", "D5", "A5"],
  ["C4", "G4", "Eb4", "Bb4", "D5", "A5"],
  ["C4", "G4", "E4", "Bb4", "D5", "A5"],
  ["C4", "G4", "E4", "Bb4", "Db5", "Ab5"],
];

let notes = chords[0];

let numBars = notes.length * 2 - 1; //array n di segmenti corrispondono alle note

//////////////sintetizzore tone Js/////////////////////////////////
const delay1 = new Tone.FeedbackDelay("8n", 0.8)
 // volume impostato su -12dB quindi all'uscita Master
  .chain(new Tone.Volume(-12), Tone.Master);

const delay = new Tone.FeedbackDelay("8n", 0.8)
  //volume impostato su -12dB quindi all'uscita Master
  .chain(new Tone.Volume(-12), Tone.Master);

const filter = new Tone.Filter(1500, "lowpass")
  // il segnale viene inviato sia al Delay che al Master
  .connect(delay)
  .toMaster();

// sintetizzatori Tone js
let synth = new Tone.PolySynth(numBars, Tone.Synth, {
  volume: -12, // il volume dell'oscillatore impostato su -12dB
  oscillator: {
    type: "triangle", //tipo di oscillatore
  },
  envelope: {
    attack: 0.02, // attacco dell'inviluppo impostato su 20 ms
    release: 1, // impostazione 1 secondo
  },
}).connect(filter); // connettere il synth con il filtro
function reflectArray(arr) {
  let revArr = arr.slice().reverse();
  arr.shift();
  let fullArr = revArr.concat(arr);
  return fullArr;
}

function triggerSynth(time) {
  playNotes = [];
  for (let i = 0; i < numBars; i++) {
    if (bars[i].playing) {
      playNotes[i] = bars[i].note;
    } else {
      playNotes[i] = 0;
    }
  }

  // numero di ripetizione della nota
  synth.triggerAttackRelease(playNotes, "4n");
}

// Dispalay sonoro

class Bar {
  constructor(x, w, n) {
    this.x = x;
    this.y = 0;
    this.w = w;
    this.h = height;
    this.a = 0;
    this.note = n;
    this.savedNote = this.note;
    this.playing = false;
  }

  display() {
    //push();
    fill(0, 40, 300, this.a); //colore segmenti
    noStroke();
    rect(this.x, this.y, this.w, this.h); // segmenti panorama audio
    // pop();
  }

  update(pos) {
    if (pos > this.x && pos < this.x + this.w) {
      this.a = 5; // opacità segmenti
      this.note = this.savedNote;
      this.playing = true;
    }
  }
  reset() {
    this.a = 0;
    this.note = 0;
    this.playing = false;
  }

  changeNote(newNote) {
    this.savedNote = newNote;
  }
}

function setup() {
  const canvas = createCanvas(1080, 600);
  canvas.parent("videoContainer");
  canvas.mousePressed(canvasPressed);
  mic = new p5.AudioIn(); // attivazione microfono
// chiedere all'utente di abilitare il microfono del browser
  mic.start();

  // creare una registrazione del suono
  recorder = new p5.SoundRecorder();

  // connettere il mic per registrare
  recorder.setInput(mic);

  //riproduci e salva la registrazione
  soundFile = new p5.SoundFile();

  if (modelReady) {
    video = createVideo("people.mp4", videoLoad);

    video.hide();

    poseNet = ml5.poseNet(video, modelReady);
    poseNet.on("pose", gotPoses);
    video.volume(0);
    // parametri scia grafica
    myHistAX0 = [];
    myHistAY0 = [];
    myHistAX1 = [];
    myHistAY1 = [];

    myHistBX0 = [];
    myHistBY0 = [];
    myHistBX1 = [];
    myHistBY1 = [];
    strokeWeight(2);
    //fill(255, 255, 255);
    //stroke(255, 255, 127, 90);
    //background(0, 0, 0);
    smooth();

    for (var i = 0; i < big; i++) {
      bodiesA[i] = new ball();
      bodiesB[i] = new ball();
    }

    let notesPattern = reflectArray(notes);
    // w è il singolo segmento
    w = width / numBars;
    for (let i = 0; i < numBars; i++) {
      bars.push(new Bar(w * i, w, notesPattern[i]));
    }
  }
}
function videoLoad() {
  video.loop();
}

// clicca sulla canvas per salvare audio
function canvasPressed() {
  // ensure audio is enabled
  userStartAudio();
// assicurati che l'utente abbia abilitato il microfono
  if (state === 0 && mic.enabled) {
    // record to our p5.SoundFile
    recorder.record(soundFile);

    background(255, 0, 0);// opacità video
    text("Recording!", width / 2, height / 2);
    state++;
  } else if (state === 1) {
    background(0, 255, 0);
// ferma il registratore e
    // invia il risultato a soundFile
    recorder.stop();

    text("Done! Tap to play and download", width / 2, height / 2, width - 20);
    state++;
  } else if (state === 2) {
    soundFile.play(); // play the result!
    save(soundFile, "mySound.wav");
    state++;
  }
}
function startPosenet() {
  poseNet = ml5.poseNet(video, modelReady);
  poseNet.on("pose", gotPoses);
}
function videoLoad() {
  video.loop();
}
//scala maggiore-minore-diatonica-alterata
function chooseChord() {
  let e = document.getElementById("Chord-Quality");
  let chordIndex = e.options[e.selectedIndex].index;
  notes = reflectArray(chords[chordIndex]);
  for (let i = 0; i < bars.length; i++) {
    bars[i].changeNote(notes[i]);
  }
}

function gotPoses(poses) {
  skelPose = poses;
   //console.log(skelPose[0]);
  posesX = [];
  posesY = [];
  if (poses.length > 0) {
    for (let i = 0; i < poses[0].pose.keypoints.length; i++) {
      if (poses[0].pose.keypoints[i].score > 0.3) {
        posesX.push(poses[0].pose.keypoints[i].position.x);
        posesY.push(poses[0].pose.keypoints[i].position.y);
        if (skelPose[0].pose.nose) {
          // regolazione volume in basso e in alto
          let volumeVal = map(skelPose[0].pose.nose,0, height, 1, -15);
          volumeVal = constrain(volumeVal, -100, 10);
        }
        if (skelPose[0].pose.leftElbow) {
          // regolazione volume in basso e in alto
          let volumeVal = map(skelPose[0].pose.leftElbow.y, 7, height, 1, -15);
          volumeVal = constrain(volumeVal, -100, 10);
    
          
          synth.volume.value = volumeVal;
          // console.log(volumeVal);
          if (poses.length > 0) {
            try {
              poseA = poses[0].pose;
            } catch (error) {
              poseA = null;
            }

            try {
              poseB = poses[1].pose;
            } catch (error) {
              poseB = null;
            }
          }
        }
      }
    }
  }
}

function modelReady() {
  console.log("model ready");
  Tone.Transport.start();
}

Tone.Transport.scheduleRepeat(triggerSynth, "4n");

function draw() {
  image(video, 0, 0);
  background(0, 130);

  for (let j = 0; j < bars.length; j++) {
    bars[j].reset();
  }
  // segmenti sonori riconoscono i keypoints
  for (let i = 0; i < posesX.length; i++) {
    for (let k = 0; k < bars.length; k++) {
      bars[k].update(posesX[i]);
      bars[k].display();
    }
  }
  drawKeypoints();
  drawSkeleton();

  if (poseA) {
    mXA += 0.3 * (poseA.leftWrist.x - mXA);
    mYA += 0.3 * (poseA.leftWrist.y - mYA);

    //circle(pose.leftWrist.x, pose.leftWrist.y, 30);

    for (var i = 0; i < big; i++) {
      bodiesA[i].recordPts(
        mXA,
        mYA,
        myHistAX0,
        myHistAY0,
        myHistAX1,
        myHistAY1
      );
    }

    if (myHistAX0.length > big * nwalker) {
      myHistAX0 = subset(myHistAX0, big); // Estrae un array di elementi da un array esistente.
      myHistAY0 = subset(myHistAY0, big);
      myHistAX1 = subset(myHistAX1, big);
      myHistAY1 = subset(myHistAY1, big);
    }
    // colore scia
    stroke("#3699EA");
    for (var j = 0; j < myHistAX0.length; j++) {
      line(myHistAX0[j], myHistAY0[j], myHistAX1[j], myHistAY1[j]);
    }
  }

  if (poseB) {
    mXB += 0.3 * (poseB.leftWrist.x - mXB);
    mYB += 0.3 * (poseB.leftWrist.y - mYB);

    //circle(pose.leftWrist.x, pose.leftWrist.y, 30);

    for (var k = 0; k < big; k++) {
      bodiesB[k].recordPts(
        mXB,
        mYB,
        myHistBX0,
        myHistBY0,
        myHistBX1,
        myHistBY1
      );
    }

    if (myHistBX0.length > big * nwalker) {
      myHistBX0 = subset(myHistBX0, big);
      myHistBY0 = subset(myHistBY0, big);
      myHistBX1 = subset(myHistBX1, big);
      myHistBY1 = subset(myHistBY1, big);
    }
    //colorMode(HSB);
    strokeWeight(1);
    stroke("#36C8EA");
    for (var l = 0; l < myHistAX0.length; l++) {
      line(myHistBX0[l], myHistBY0[l], myHistBX1[l], myHistBY1[l]);
    }
  }
}
//disegna i keypoints
function drawKeypoints() {
  for (let i = 0; i < skelPose.length; i++) {
    //Per ogni posa rilevata, scorre tutti i keypoints
    let pose = skelPose[i].pose;
    for (let j = 0; j < pose.keypoints.length; j++) {
      // A keypoint is an object describing a body part (like rightArm or leftShoulder)
      let keypoint = pose.keypoints[j];
      //Disegna solo un'ellisse se la probabilità di posa è maggiore di 0.2
      if (keypoint.score > 0.2) {
        //  fill(255);

        ellipse(keypoint.position.x, keypoint.position.y, 5, 5);
      }
    }
  }
}

// classe scia grafica
class ball {
  constructor() {
    this.X = random(screen.width);
    this.Y = random(screen.height);
    this.w = random(1 / thold, thold);
    this.Xv = 0.0;
    this.Yv = 0.0;
    this.pX = 0.0;
    this.pY = 0.0;
  }

  recordPts(mX, mY, myHistX0, myHistY0, myHistX1, myHistY1) {
    if (!mouseIsPressed) {
      this.Xv /= spifac;
      this.Yv /= spifac;
    }
    this.Xv += drag * (mX - this.X) * this.w; // cambia i parametri della scia se ti muovi con il mouse
    this.Yv += drag * (mY - this.Y) * this.w;

    this.X += this.Xv;
    this.Y += this.Yv;

    myHistX0.push(this.X);
    myHistY0.push(this.Y);
    myHistX1.push(this.pX);
    myHistY1.push(this.pY);

    this.pX = this.X;
    this.pY = this.Y;
  }
}
//disegna scheletro
function drawSkeleton() {
  for (let i = 0; i < skelPose.length; i++) {
    let skeleton = skelPose[i].skeleton;

    for (let j = 0; j < skeleton.length; j++) {
      let a = skeleton[j][0];
      let b = skeleton[j][1];
      // stroke(0,90,160);   strokeWeight(3);
      line(a.position.x, a.position.y, b.position.x, b.position.y);
    }
  }
}
